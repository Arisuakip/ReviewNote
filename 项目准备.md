<h4>项目准备</h4>

**Q：项目介绍**

项目搭建了一个Linux环境下的简易WebServer，主要功能是通过HTTP协议与客户端（浏览器）进行通信，接受并处理来自客户端的HTTP请求，并对请求作出HTTP响应，返回给客户端其请求的内容。

**如何建立连接：**用户使用浏览器与相应服务器通信，在浏览器中输入相应IP地址：端口，浏览器根据IP地址与服务器经过TCP三次握手建立TCP连接并发送一个HTTP请求，服务器端根据收到的HTTP请求报文通过TCP连接将响应报文发送到目标客户端。

远端用户尝试连接WebServer上正在被监听的端口，服务端使用I/O复用技术epoll同时监听监听socket和连接socket，当监听socket监听到新的客户连接时，使用accept建立连接并将客户连接**connfd**注册到内核事件列表。

**处理HTTP请求**：项目使用**线程池实现**并发处理客户请求，由主线程负责读写，工作线程（线程池中的线程）负责处理逻辑，比如解析HTTP请求等。

服务端通过**epoll_wait**发现**connfd**发现有可读事件，主线程将**HTTP请求报文**读入到连接socket的读缓存中，然后将该任务对象（指针）**插入线程池的请求队列**中，线程池的实现还需要依靠**锁机制**以及**信号量**机制来实现线程同步



<h4>半同步/半反应堆线程池</h4>

___

**Q：五种I/O模型**

**同步I/O1-4：等待IO操作完成，才能继续进行下一步操作。**

+ **阻塞IO：**调用函数后一直等待函数返回，返回后才有下一步动作
+ **非阻塞IO：**非阻塞I/O会立即返回，每隔一段时间就去检测IO事件是否就绪，根据errno区分两种情况
+ **信号驱动IO：**当进程调用I/O函数，不会阻塞等待I/O操作完成，进程将请求发送给操作系统，并继续执行。当操作系统完成IO时，它会向进程发送一个信号来通知它。进程使用**sigaction（）**函数来捕获信号
+ **I/O复用：**linux用**select/poll/epoll**实现**IO复用模型**，可以同时阻塞多个IO操作，同时对多个读操作、写操作的IO函数进行检测，有数据可读或可写时，才真正调用IO操作函数。

**异步IO：**

+ **异步IO：**程序只发出IO指令，并不等待IO结果，由内核完成IO操作，当IO返回结果时，再通知应用程序进行处理。（aio_read函数)



**Q：I/O多路复用**

什么是I/O多路复用：一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，多个请求复用了一个进程，这就是多路复用。

 select/poll/epoll 内核提供给用户态的多路复用系统调用，**进程可以通过一个系统调用函数从内核中获取多个事件**。

+ **select/poll：**将已连接的 Socket 都放到一个**文件描述符集合**并拷贝到内核里，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里。需要进行 **2 次「遍历」文件描述符集合**，而且还会发生 **2 次「拷贝」文件描述符集合**
+ **epoll：**将需要监视的socket添加到epfd中，epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中
  + **ET边缘触发：**
    + epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序**必须立即处理该事件**
    + 必须要**一次性将数据读取完**，使用非阻塞I/O，**读取到出现eagain**
  + **LT水平触发：**
    + epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序可以不立即处理该事件。
    + **下一次调用epoll_wait时**，epoll_wait还会**再次向应用程序报告**此事件
  + **EPOLLONESHOT：**
    + 避免一个socket被两个线程同时处理
    + 通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，**当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件**



**Q：两种事件处理模式：Reactor和Proactor**

**Reactor 模式：**

Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；

处理资源池负责处理事件，如 read -> 业务逻辑 -> send；

主线程Reactor监听文件描述符是否有事件发生；当有可读/可写事件发生时，主线程通知请求队列上的工作线程，读数据或者写数据，**通常由同步IO实现**

**Proactor模式：**

Proactor将所有I/O操作都交给主线程和内核处理，工作线程仅负责业务逻辑，**通常由异步IO实现**

+ 主线程调用异步IO函数向内核注册socket上的读完成事件，告诉内核用户读缓冲区的位置，以及如何通知应用程序
+ 完成后，内核通知应用程序读完成
+ 工作线程处理客户请求，通知内核执行写操作
+ 工作线程进行善后处理



**Q：为什么不直接用异步IO实现Proactor，反而用同步IO实现**

异步IO并不成熟，实际使用较少，所以用同步IO来模拟实现proactor模式

**实现流程：**

+ 主线程在内核事件表中，注册socket的读就绪事件
+ 主线程调用`epoll_wait`，等待socket读事件发生
+ 当socket有数据可读时，内核事件表通知主线程，主线程从socket中读取数据，并将读取的数据封装成一个请求对象并插入请求队列
+ 睡眠在请求队列上的某个工作线程被唤醒，获得工作对象并处理客户请求，处理完毕后，向epoll内核实际表中注册写就绪事件
+ `epoll_wait`通知主线程有数据可写，主线程将请求结果写入socket中



**并发编程模式：**

并发模式指I/O处理单元和多个逻辑单元之间协调任务的方法

**半同步/半异步模式**

+ 同步线程用于处理客户逻辑
+ 异步线程用于处理I/O事件
+ 异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中
+ 请求队列将通知某个工作在**同步模式的工作线程**来读取并处理该请求对象

**半同步/半反应堆模式**（模拟Proactor）

+ 主线程充当**异步线程**，负责监听所有socket上的事件
+ 主线程接收新连接请求以得到新的连接socket，向epoll内核事件表中注册该socket的读写事件
+ 若有读写事件发生，主线程从socket接受数据，并将数据封装成请求对象，放入请求队列中
+ 所有工作线程睡眠在请求队列上，当有任务到来时，通过**竞争获得任务的接管权**

半同步/半反应堆是半同步/半异步模式的一个变种，Reactor模式下，工作线程需要自己处理客户请求的读取与响应的写入（同步模式），Preactor模式下，由反应堆线程完成IO

**半同步/半反应堆模式的缺点：**

+ 主线程和工作线程**共享请求队列**
+ 每个工作线程**同一时间只能处理一个客户请求**





**Q：为什么要用线程池？直接创建不行吗**

+ 用空间换时间，用**硬件资源换取运行效率**
+ 服务器正式运行时，可以直接从池中获取资源,**无需动态分配**
+ 当处理完一个客户连接后,可以把相关的资源放回池中,**无需执行系统调用释放资源**
+ 池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为**静态资源**



**Q：怎么创建一个线程？**

```c++
#include<pthread.h>
int pthread_create (pthread_t *thread_tid,              //返回新生成的线程的id
                    const pthread_attr_t *attr,         //指向线程属性的指针,通常设置为NULL
                    void * (*start_routine) (void *),   //处理线程函数的地址
                    void *arg);                         //start_routine()中的参数
```



**Q：你实现的线程池是什么？**

使用一个**pthread_t类型的数组**，通过`pthread_create()`函数**创建一定数量的线程**，为每个线程设置**处理线程函数**，不断**从请求队列中取出任务并执行**，使用**信号量标识**请求队列中的请求数，每个线程等待一个任务。并将每个线程使用`pthread_detach()`**设置为脱离态**，使线程结束时，资源被系统立即回收。



**Q：线程池中的数量怎么确定？**

对于CPU密集型来说：最好设置为CPU的核数

对于IO密集型来说：最佳线程数 = **CPU当前可使用的Cores数 *当前CPU的利用率 * (1 + CPU等待时间 / CPU处理时间)**（取了8）



**Q：工作线程是怎么等到任务来执行的？请求队列是什么？**

**请求队列：**使用**List容器**创建请求队列，主线程向请求队列添加任务时，需要加互斥锁，添加完成后，通过信号量通知工作线程有新任务到达。

**工作线程：**首先调用**信号量的wait函数等待信号量**，某一个工作线程**被唤醒**后，**先加互斥锁**，**从请求队列中取出第一个任务**，并将其删除，调用处理函数进行处理



**Q：怎么创建一个简单的线程池？（手写一个？）**

```c++
template<typename T>
class threadpool
{
    public:
    	threadpool(int thread_number = 8,int max_request = 10000);//构造函数
    	~threadpool();
    private:
    	static void* worker(void* arg);//处理线程函数
    private:
    	int m_thread_number;//线程数
    	int m_max_requests; //最大连接数
    	pthread_t* m_threads; //线程数组
}

template<typename T>
threadpool<T>::threadpool(int thread_number,int max_requests):m_thread_number(thread_number),m_max_requests(max_requests),m_threads(NULL)
{
    if(thread_number <= 0 || max_request <= 0) throw std::exception();
    
    //初始化线程id
    m_threads = new pthread_t[m_thread_number];
    if(!m_threads) throw std::exception(); //创建失败
    for(int i=0;i<thread_number;i++)
    {
        if(pthread_create(m_threads+i,NULL,worker,this) != 0)
        {
            delete[] m_threads;
            throw std::exception();
        }
        if(pthread_detach(m_threads[i])) //分离线程，不用单独对工作线程进行回收
        {
            delete[] m_threads;
            throw std::exception();
        }
    }
}
```





<h4>HTTP连接处理——处理请求报文</h4>

___

**Q：说说总的HTTP报文处理流程**

+ 浏览器端发出http连接请求，主线程**创建http对象接收请求并将所有数据读入对应buffer（m_read_buf缓冲区）**，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。
+ 工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。
+ 解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。  



**Q：有限状态机**

能够把**有限个变量描述的状态变化过程**，以可构造可验证的方式呈现出来。比如，封闭的有向图。

**在主状态机中进行循环**，循环**对报文的每一行进行处理**，判断三种状态分别调用对应的函数

**主状态机：对报文的一行进行解析**

调用get_line获得一行text。分别调用对应函数

+ **CHECK_STATE_REQUESTLINE：**解析请求行，转移至CHECK_STATE_HEADER
  + 请求行格式：GET/POST/t/somedir/page.html/tHTTP/1.1
  + 提取报文种类GET/POST、URL、以及HTTP版本
+ **CHECK_STATE_HEADER：**解析请求头，获得处理请求头完成时转移至CHECK_STATE_CONTENT
  + 提取Connection（长短连接）、Content-length（报文长度）、Host（连接地址）、
+ **CHECK_STATE_CONTENT：**，解析消息体，仅用于解析POST请求

**从状态机：读取报文的完整一行**

逐字读取读缓存区，判断字符：如果是\r\n就有可能读取到完整的一行，否则说明行不完整

不是\r或者\n说明读取的行不完整，接着读取

+ **LINE_OK：**完整读取一行
+ **LINE_BAD：**报文语法有误
+ **LINE_OPEN：**读取的行不完整



<h4>HTTP连接处理——处理响应报文</h4>

___

**Q：服务器是怎么处理响应报文的？**

服务器首先根据请求报文的URL，判断需要请求什么资源？之后判断文件请求是否合法，如果文件合法，使用系统调用open获得该文件描述符，并用mmap将其映射到内存中。返回请求文件存在，允许访问。否则返回相应错误码

之后根据返回的状态，子线程向写入缓存区写入响应报文。添加状态行、消息报头和空行

资源包含：注册界面、登陆界面、图片等。



**Q：具体怎么写入响应报文的？**

服务器首先根据请求报文的URL，判断需要请求什么资源以及是否合法，根据返回的状态码，添加相应的报文：比如请求资源有误或不存在返回404，请求资源无权限返回403等，请求文件合法返回200，写入状态行、消息报头、并使用2个iovec指针分别指向响应报文缓冲区以及mmap返回的文件指针。子线程**完成响应报文的准备**。随后注册EPOLLOUT事件，**通知主线程可以将响应报文发送给客户端**。

**响应报文写入写缓冲区**：维护一个m_write_idx指针，代表写入缓冲区的大小，每次写入一行时，判断是否超过了写入缓冲区大小，随后逐行写入状态行、消息报头（比如Content—Length响应报文长度；Content—Type：文本类型text/html；Connection：是否关闭连接（由客户端关闭）；添加空行；添加文本内容

**主线程发送函数：**在**生成响应报文时初始化头部信息和文件数据大小**。通过**writev函数循环发送响应报文**数据，根据返回值更新已发送字节和iovec结构体的指针和长度，如果发送失败，判断是否为缓冲区已满，如果是缓冲区满了，就更新指针和长度，重新注册写事件。根据发送长度判断响应报文整体是否发送成功。成功后取消文件映射，并重置socket监听事件。如果是长连接，就重新初始化HTTP对象，否则通知客户端中断连接



**Q：怎么实现传输文件？（讲一下mmap）**

为了提高访问速度，通过mmap进行映射，将普通文件映射到内存逻辑地址。

+ mmap函数用于**申请一段内存空间**，将这段内存作为进程间通信的**共享内存**
+ munmap函数用于释放这段内存空间

```
void* map(void *start,size_t length,int prot,int flags,int fd,off_t *offset);
```



<h4>优化—处理非活跃连接</h4>

___

对于与服务器建立连接后长时间不交换数据的连接，需要及时关闭以避免资源浪费，客户端为每一个连接创建一个定时器，包含**连接资源、定时事件和超时时间**，并对每个连接进行定时。利用**升序时间链表将所有定时器串联**起来，若主循环**接收到定时通知**，则在链表中**依次执行定时任务**。



**Q：信号是怎么工作的？**

Linux的信号为**异步处理机制**，操作系统会中断进程当前的正常流程，转而进入信号处理函数执行操作，完成后再返回中断的地方继续执行。在此期间，系统会将信号屏蔽不再触发信号，因此应该**尽量让信号处理函数执行时间减少**，**这里仅让信号处理函数通知主循环，将处理逻辑放在主循环中**

**信号本身是整型数值**



**Q：主线程要怎么检测信号到来？如何通知主线程的？整个信号通知的流程**

采用**统一事件源**的方式，将信号事件与其他事件一同处理，使用I/O复用将管道加入监听列表，监听读事件，以此将信号与其他文件描述一并处理。

+ 创建管道，将管道读端加入I/O复用系统检测读事件

+ 通过struct sigaction结构体和sigaction函数注册信号处理函数
+ 信号处理函数使用管道将信号传递给主循环，信号处理函数向管道的写端写入信号值
+ 利用I/O复用系统监听管道读端文件描述符的可读事件，主线程从管道的读端读出信号值
+ 主循环根据接收到的信号值执行目标信号对应的逻辑代码



**Q：信号处理机制（详细）**

+ 信号接收：内核接收信号后，向进程发送一个中断，使进程进入内核态
+ 信号检测：进程在内核态中进行信号检测（返回用户态前或者从睡眠状态被唤醒），发现有信号时，对信号进行处理
+ 信号处理：信号处理函数运行在用户态，内核将会当前内核栈的内容拷贝到用户栈上，并修改指令寄存器将其指向信号处理函数，返回用户态执行信号处理函数，处理完成后返回内核态，检查是否有信号需要继续处理，如果处理完毕，恢复内核栈，会到中断前位置继续执行。



**Q：有哪些定时方法**

+ socket选项中选项：仅对socket专用的系统调用（send,sendmsg,recv,recvmsg,accept,connect）有效，结合errno判断
+ I/O复用系统超时参数：三组IO复用系统调用都有超时参数，但有可能提前返回，因此不断重新定时，以保证时间正确
+ SIGALRM信号：利用alarm函数周期性触发SIGALRM信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。



**alarm函数**

即用来设置信号SIGALRM在经过参数seconds秒数后发送给目前的进程

`unsigned int alarm(unsigned int seconds);`



**Q：定时器类都包含什么内容？**

+ **连接资源：**包括客户端套接字地址、文件描述符和定时器
+ **定时事件：**回调函数：从内核事件表中删除事件，关闭文件描述符，释放连接资源
+ **定时器超时时间**：浏览器和服务器连接时刻 + 固定时间(TIMESLOT)  20s



**Q：怎么设计的升序链表？怎么生效的？**

项目中的定时器容器为**带头尾结点的升序双向链表**，为每个连接创建一个定时器，将其添加到链表中，按超时时间进行升序排列，执行任务时，将到期的定时器从链表中删除。

**核心函数：**

+ 添加定时器：只有头尾结点时直接插入/否则将定时器按升序插入
+ 调整定时器：客户端在时间内有收发操作，重新设定定时器时间，如果本来就在队尾就不动，如果先将定时器取出，再执行按升序插入。
+ 删除定时器：双向链表删除



**Q：定时任务处理**

每当SIGALRM信号被触发时，主循环中调用一次定时任务处理函数，处理到期定时器

+ 遍历链表，直到遇到尚未到期的容器
+ 当前时间小于超时时间，说明未过期，结束处理
+ 当前时间大于超时时间，找到过期的定时器，执行回调函数，将其删除继续遍历。



**Q：服务器会对定时器做哪些操作？**

+ 初次建立连接时，创建该连接定时器，并添加到链表上
+ 服务器端关闭连接时，移除对应定时器
+ 服务器端进行读操作时，重新设置超时时间，并调整定时器位置
+ 服务器端进行写操作时，如果发送了数据，重新设置超时时间，并调整定时器位置



<h4>数据库连接池</h4>

在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，更加安全可靠。

**Q：怎么创建的数据库连接池？**

使用单例模式的懒汉式创建连接池，并将信号量初始化为数据库的连接总数

**Q：怎么获得连接？**

当线程数量大于数据库连接数量时，使用信号量进行同步，每次取出连接，信号量原子减1，释放连接原子加1，若连接池内没有连接了，则阻塞等待。对于多线程操作，可能会造成竞争，因此在获得连接前上互斥锁

**Q：如何实现的登陆检验？**

将数据库中的用户名和密码载入到服务器的map中，当解析为POST请求的时候，提取出用户名和密码进行校验。根据url判断是注册还是登陆，如果是注册，先检查是否注册过，如果是登陆，就直接在map里寻找。