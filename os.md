<h4>OS一些题</h4>

**Q：进程与线程区别？**

<b>(1)资源：</b>进程是资源分配的单位，而线程不拥有资源，只能访问所属进程的资源

进程拥有哪些资源：CPU、内存、文件、句柄等

线程共享：堆、全局变量、静态变量、指针引用

<b>(2)调度：</b>线程是独立调度的单位，从进程A的线程切换到进程B的线程中时，会发生进程切换

<b>(3)系统开销：</b>创建和撤销、切换时：进程所需开销远大于线程，进程需要系统分配或回收资源。进程需要保存当前进程的CPU环境及设置新调度进程的CPU环境，而线程只需保存和设置少量寄存器内容和栈指针。

<b>(4)通信：</b>线程之间可读写同一进程中的数据进行通信，进程通信需要通过IPC

**(5)并发：**多个进程并发执行，一个进程内多个线程并发执行



**Q：进程间通信方法？**

怎么查看用了哪些？：ipcs -a （能看见456）

1. **文件：**进程间可通过fork、exec及文件系统传送文件
2. **无名管道Pipe：**数据单向，只存在于内存中，父子关系进程、半双工
3. **命名管道FIFO：**半双工，允许无亲缘进程通信
4. **消息队列：**消息的链表，其存放在内核中并由消息队列标识符标识。
5. **共享内存：**映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，多个进程访问。<b>效率最高、最快的IPC方式</b>
6. **信号量：**信号量是计数器，用来控制多个进程对共享资源访问，通常作为一种**锁机制**，作为进程间以及同一进程内不同线程之间的同步手段。
7. **信号：**通知接收进程事件发生
8. **unix域套接字：**用于在同一台计算机上运行的进程之间的通信，其可以在两个进程间传送打开文件描述符。
9. **套接字Socket：**可用于不同机器间的进程通信。



**Q：进程调度算法**

+ **先来先服务：**非抢占、不利于短作业
+ **时间片轮转：**给每个进程分一个时间片，先来先服务
+ **短作业优先：**非抢占、饥饿
+ **最短剩余时间优先：**抢占式、饥饿
+ **多级反馈队列：**最重要、分为多个时间片大小：优先级不同的队列，进程在第一个队列没执行完，就被移至下一个时间片大更大的队列



**Q：进程同步方法**

**临界区：**对临界资源进行访问的代码，进入前进行检查

**同步和互斥：**

同步：多个进程因合作产生的直接制约关系，使得进程有一定的先后执行关系。

互斥：多个进程在同一时刻只有一个进程能进入临界区。

**信号量：**信号量是整型变量，能够执行pv操作



**Q：什么是虚拟内存？**

让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存，程序所使用的内存地址叫做**虚拟内存地址**，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，**来转换变成物理地址**，然后**再通过物理地址访问内存**

+ 虚拟内存可以使得进程对运行内存超过物理内存大小
+ 每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的



**Q：讲讲用户态和内核态**

**用户态：**指的是运行在 CPU 上的应用程序代码执行状态，它只能访问受限的计算机资源，如内存、CPU 等，并不能直接访问操作系统的资源，如文件、网络等。需要向操作系统**发出系统调用请求**才能访问操作系统的资源。

**内核态：** 指的是CPU 执行操作系统内核代码的运行状态，CPU 可以**访问计算机的所有资源**，包括内存、磁盘、网络等。在内核态下，操作系统可以执行任何操作，并且可以对硬件进行控制，如打开文件、读写磁盘、网络通信等。

**切换：**当用户态需要访问操作系统的资源时，需要发出系统调用，操作系统会将应用程序从用户态切换到内核态，完成系统调用后再切换回用户态。需要一定的时间和资源*（上下文切换、权限检查、系统调用处理）



**Q：讲讲协程吧**

协程是一种用户态的轻量级线程，先将寄存器上下文和栈保存，等切换回来的时候再进行恢复，不会进入内核态，由用户手动切换，可以避免线程切换的开销，提高程序的运行效率。



**Q：I/O多路复用**

什么是I/O多路复用：一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，多个请求复用了一个进程，这就是多路复用。

 select/poll/epoll 内核提供给用户态的多路复用系统调用，**进程可以通过一个系统调用函数从内核中获取多个事件**。

+ **select/poll：**将已连接的 Socket 都放到一个**文件描述符集合**并拷贝到内核里，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里。需要进行 **2 次「遍历」文件描述符集合**，而且还会发生 **2 次「拷贝」文件描述符集合**
+ **epoll：**将需要监视的socket添加到epfd中，epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**，当某个 socket 有事件发生时，通过**回调函数**内核会将其加入到这个就绪事件列表中
  + ET边缘触发：只提醒一次 ，搭配非阻塞I/O 和LT水平触发：一直提醒直到处理



**Q：讲讲Reactor和Proactor**

**Reactor 模式：**

Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；

处理资源池负责处理事件，如 read -> 业务逻辑 -> send；

主线程Reactor监听文件描述符是否有事件发生；当有可读/可写事件发生时，主线程通知请求队列上的工作线程，读数据或者写数据

**Proactor模式：**

Proactor将所有I/O操作都交给主线程和内核处理：

+ 主线程调用异步IO函数向内核注册socket上的读完成事件，告诉内核用户读缓冲区的位置，以及如何通知应用程序？
+ 完成后，内核通知应用程序读完成
+ 工作线程处理客户请求，通知内核执行写操作
+ 工作线程进行善后处理



**Q：死锁条件**

+ 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。

- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

**Q：解决死锁？**

+ 鸵鸟策略
+ 死锁检测与恢复
+ 死锁恢复：抢占、回滚、杀死进程
+ 死锁预防：破坏四个条件



**Q：页面置换算法**

当需要访问的页面不在内存中时，发生缺页中断，并将页调入内存中；若此时内存中空间已满，则需要将一个页面换出来腾出新的空间。

<b>1.最佳(OPT, Optimal replacement algorithm)</b>

被换出的页面是最长时间内不再被访问的页面

<b>2.最近最久未使用(LRU, Least Recently Used)</b>

LRU 将最近最久未使用的页面换出。

实现方式：维护一个所有页面的链表，当一个页面被访问时，将其移动至表头，使得链表尾的页面是最近最久未访问的。

<b>3.最近未使用算法(NRU, Not Recently Used)</b>

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。

首先淘汰R位为0的页面，其次淘汰R位为1M位为0的页面，最后淘汰R位为1M位也为1的页面。

<b>4.先进先出FIFO算法</b>

换出最先进入的页面，但因此会将经常被访问的页面换出，导致缺页率提高

<b>5.第二次机会算法</b>

FIFO的改进，当页面被访问时，将该页面的R位置1，在淘汰页面时，优先检查最老页面的R位，如果为1，则将其置0，并放入链表尾端，相当于修改了其进入时间，如果为0，这说明页面又老又没有被使用，则将其淘汰。

<b>6.时钟算法</b>

第二次机会算法的改进，因为第二次机会算法需要在链表中移动页面，导致效率较低，因此将其改为环形链表，而使用一个指针指向最老的页面，这样移动指针即可。



**Q：磁盘调度算法**

**1.先来先服务FCFS**

按磁盘请求顺序调度，公平简单，但未做任何优化

**2.最短寻道时间优先**SSTF

优先调度与当前磁头所在磁道距离最近的磁道。部分磁道（如两端）会发生饥饿现象

**3.电梯算法SCAN**

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。



**Q：内存分配算法**

+ **首次适应算法：**每次都从低地址开始查找，找到第–个能满足大小的空闲分区。
+ **最佳适应算法：**优先使用更小的空闲区。空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链
+ **最坏适应算法：**优先使用最大的连续空闲区，和最佳适应相反
+ **邻近适应算法：**每次都从上次查找结束的位置开始检索



**Q：线程/进程的生命周期包括五个阶段：**

1. 创建（New）：线程对象被创建，但是还没有开始执行。在这个阶段，线程对象被分配内存空间，并初始化必要的数据结构。
2. 就绪（Ready）：线程已经被创建，但是还没有开始执行。在这个阶段，线程已经准备好运行，等待被调度执行。当线程获得了CPU时间片时，它会进入运行状态。
3. 运行（Running）：线程正在执行代码。在这个阶段，线程被分配CPU时间片并且开始执行它的代码。
4. 阻塞（Blocked）：线程被暂停执行，等待某个条件的满足，比如等待一个输入输出操作的完成或者等待获取一个锁。在这个阶段，线程不会占用CPU时间，直到条件被满足时，线程会被唤醒并且重新进入就绪状态。
5. 终止（Terminated）：线程完成了它的任务，或者由于某些原因出现异常而被强制结束。在这个阶段，线程已经执行完毕，所有相关的资源（比如内存）已经被释放。



**Q：逻辑地址怎么变成物理地址？**

借助进程的页表将逻辑地址转换为物理地址

系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。

**内存管理单元** （*MMU*）就做将虚拟内存地址转换成物理地址的工作。

+ 根据逻辑地址计算出页号页内偏移量
+ 根据页号，从页表里面，查询对应的物理页号；
+ 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

把**最常访问的几个页表项**存储到访问速度更快的硬件，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB ，通常称为**页表缓存、转址旁路缓存、快表等。**

+ 有快表：算完页号后直接查快表，若命中直接获得内存块号；未命中再查页表；（命中一次访寸、否则两次访寸）



**Q：典型的锁？**

+ **读写锁**
+ **互斥锁：**互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒
+ **条件变量：**某个线程改变了条件变量，通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程，同步机制
+ **自旋锁：**一直循环等着
+ 

**Q：线程锁**

+ 互斥锁
+ 条件变量
+ 自旋锁



**虚拟技术**

+ **时分复用技技术**：多个进程能在同一个处理器上并发执行
+ **空分复用技术：**虚拟内存使用了空分复用技术



**操作系统基本功能：**

**进程管理：**进程控制、进程同步、进程通信、死锁处理、处理机调度(?)

**内存管理：**内存分配、地址映射、内存保护、虚拟内存

**文件管理：**文件存储空间管理、目录管理、文件读写管理和保护

**设备管理：**完成IO请求



**Linux 用过么？怎么查看内存使用情况？怎么查看负载均衡？怎么查看堆和栈？**

+ 内存使用情况：free
+ CPU使用情况：top
+ 负载均衡：uptime、more /proc/loadavg（显示1s、5s平均负载）
+ 查看栈：pstack
+ 查看网路连接：netstat -atunp   t-tcp  u-udp
+ 查看磁盘使用情况：df -h

