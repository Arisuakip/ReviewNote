<h4>数据库</h4>

**Q：关系型数据库和非关系型数据库区别**

**关系型数据库：**

+ 采用关系模型组织数据
+ 支持复杂查询
+ 能保证数据一致性

**非关系型数据库：**

+ 不需要经过SQL层的解析，读写效率高。
+ 基于键值对，数据的扩展性好。
+ 支持多种类型数据的存储



**Q：为什么要使用索引？**

+ 加快数据检索速度（主要）
+ 帮助服务器避免排序和临时表
+ 将随机IO变为顺序IO
+ 加快表之间的连接



**Q：索引为什么能加快检索速度？**

索引能将无序的数据变成相对有序的数据，相当于书的目录



**Q：说说索引的类型**

**按数据结构分：**

+ **FULLTEXT全文索引**：对文本的内容进行分词，进行搜索
+ **HASH索引：**H一次定位，不需像树形索引那样逐层查找
+ **B+Tree索引：**将索引值按一定的算法，存入树结构，每次查询从root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。

**按物理存储分：**

+ **聚簇索引（主键索引）：**按照一定规则排列的目录称为"聚集索引，**默认使用的是 B+Tree 索引**
  + 有主键时，使用主键作为聚簇索引
  + 没有主键时，选择第一个不包含空值的唯一列作为聚簇索引
  + 两个都没有，InnoDB 自动生成一个隐式自增 id 列作为聚簇索引的索引键
+ **二级索引（辅助索引）：**
  + 其它索引都属于辅助索引

**按字段特性分：**

+ **主键索引**：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
+ **唯一索引**：加速查询 + 列值唯一（可以有null）
+ **普通索引**：仅加速查询
+ **前缀索引**

**按字段个数分**

+ **单列索引**
+ **联合索引**：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

**覆盖索引：**索引包含所有需要查询的字段的值，避免再回到表格中检索数据行



**Q：什么时候需要建立数据库索引？**

在最频繁使用的、用以缩小查询范围的字段,需要排序的字段上建立索引。

注意字段最好非空，离散值最好大，选取经常被查询的字段



**Q：什么时候索引会失效？**

+ 对索引列**使用函数或者运算**
+ 避免在where中使用**否定操作符**
+ 模糊匹配like语句可能导致索引失效：`like %xx` 或者 `like %xx%`
+ 对索引隐式类型转换
+ 联合索引非最左匹配
+ WHERE 子句中的 OR



**Q：那为什么不每列都建一个索引？**

+ 对表中数据进行增删改的时候，**索引需要动态维护**，降低了数据的维护速度。
+ **索引需要占物理空间**
+ **创建索引和维护索引要耗费时间**，这种时间随着数据量的增加而增加



**Q：讲讲B+树**

B+Tree 是一种多叉树

+ 叶子节点才存放数据，非叶子节点只存放索引
+ 每个节点里的数据**按主键顺序存放**，叶子节点中包括所有的索引值信息
+ 叶子节点之间构成一个有序链表



**Q：为什么数据库用B+树，不用B树**

需求：尽可能少的磁盘 I/O 操作、高效地查询某一个记录，高效地执行范围查找。

存储：文件与数据库需要大量空间存储，需要存储到磁盘上。为了数据的快速定位与查找，**索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数**

B树的缺点：

+ B 树的每个节点都包含数据（索引+记录），需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。
+ 无关的记录也会被加载到内存中，实际上这些数据没有意义
+ 范围查询需要进行中序遍历

B+树的优点：

+ **B+树的非叶子节点可以存放更多的索引**，比B树更矮胖，I/O次数会更少
+ B+ 树有大量的冗余节点，B+树删除节点只需要改变叶子结点。
+ **B+ 树所有叶子节点间链表连接**，范围查询非常方便



**Q：为什么不用哈希表？**

Hash 在做等值查询的时候效率高，但**不适合做范围查询**



**Q：讲讲InnoDB和MyISAM**

**InnoDB**

+ MySQL 默认的**事务型存储引擎**，可以使用 `Commit` 和 `Rollback` 语句。
+ 实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)，通过通过**多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻读**。
+ 主索引是**聚簇索引**，内部做了很多优化，支持真正的在线热备份、
+ **支持外键**

**MyISAM**

+ 设计简单
+ 提供了大量的特性，包括压缩表、空间数据索引等
+ **不支持事务**
+ **不支持行级锁，**只能对整张表加锁



**Q：讲一下数据库的隔离级别**

+ **READ-UNCOMMITTED 未提交读：**
  + 修改事务但未提交，其他事务使用该修改，但原事务回滚。可能**会导致脏读、幻读或不可重复读**
  + 直接读取最新的数据就能实现
+ **READ-COMMITTED 提交读：**
  + 事务提交之前，对其他事务不可见，**可以阻止脏读，无法阻止幻读或不可重复读**
  + **每次读取数据时，都会生成一个新的 Read View**
+ **REPEATABLE-READ 重复读（默认级别）：**
  + 对一个记录读取多次的记录是相同的，**可以阻止脏读和不可重复读，无法阻止幻读**
  + 启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View
+ **SERIALIZABLE 可串行化读：**
  + 并发情况下，**防止脏读、不可重复读以及幻读**
  + 通过加读写锁方式避免并行访问



**Q：数据库并发事务会带来哪些问题？/什么是脏读、幻读、丢弃修改、不可重复读**

**脏读：**事务A修改数据，事务B读取了修改后的数据，但事务A发生回滚

**幻读：**事务A对某个范围进行了修改，事务B多次读取发生数据量变化了

**丢弃修改：**两个事务AB同时对某个数据操作，导致两次修改覆盖

**不可重复读：**事务B第一次读取数据后，事务A修改了数据，事务B再次读取时，发现结果不一致



**Q：事务四大特性？**

+ **原子性：**一个事务中的所有操作，要么全部完成，要么全部不完成
  + 通过**回滚日志：undo log**保证，事务回滚时能够撤销所有已经成功执行的 SQL语句
+ **一致性：**事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。
  + 通过持久性+原子性+隔离性来保证
+ **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力
  + 通过**MVCC多版本并发控制或锁机制**保证
+ **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
  + 通过**重做日志：redo log**保证，在**redo log**中记录这次操作



**Q：为啥需要回滚？**

恢复机制是通过回滚日志（undo log）实现， 当事务已经被提交之后，就无法再次回滚了

能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息

系统发生崩溃，再次启动时将之前未完成的事务进行回滚



**Q：Mysql怎么保证大多数情况下不幻读的？**

+ 针对**快照读**（普通 select 语句），**通过 MVCC 方式解决幻读**

**多版本并发控制MVCC：**

在事务执行第一个查询语句后，会创建一个 **Read View**，**后续的查询语句利用这个 Read View**，通过这个 Read View 就**可以在 undo log 版本链找到事务开始时的数据**，所以**事务过程中每次查询的数据都是一样的**，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。

+ 针对当前读（select ... for update语句），通过**next-key lock（记录锁+间隙锁）方式解决幻读**

MySQL 里除了普通查询是快照读，其他都是**当前读**，比如 update、insert、delete，语句执行前都会**查询最新版本的数据**，然后再做进一步的操作。当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。



**Q：READ_VIEW到底是什么？**

READ_VIEW**四个重要字段**：

+ **m_ids：**在创建Read View时，当前数据库中「活跃事务（**启动但还没提交的事务**）」的**事务 id 列表**
+ **min_trx_id：**创建**Read View时，当前数据库中「活跃事务」中事务 **id 最小的事务**
+ **max_trx_id：**创建 Read View 时当前数据库中应该给下一个事务的 id 值，全局事务最大的事务 id 值 + 1
+ **creator_trx_id：**创建该 Read View 的事务的**事务 id**。

**事务ID与trx_id的关系**：

+ 当事务ID小于min_trx_id：说明该事务已提交
+ 当事务ID大于max_trx_id：说明该事务尚未开始
+ 当事务ID介于二者之间：说明该事务已启动但未提交

**InnoDB**聚簇索引中的**隐藏列**：

+ **trx_id：**当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**
+ **roll_pointer：**每次对记录改动时，把旧版本的记录写入到 undo 日志中，**是个指针，指向每一个旧版本记录**，通过该指针找到修改前的记录

​	MVCC**版本链控制：**

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC**

+  **trx_id 小于 min_trx_id：**说明该记录是在创建Read View之前已提交的事务生成，对当前事务**可见**
+ **trx_id 大于 min_trx_id：**说明该记录是在创建Read View之后才启动的事务生成，对当前事务**不可见**
+ **trx_id 在 min_trx_id和max_trx_id之间：**判断 trx_id 是否在 m_ids 列表中
  + 在列表中：说明活跃事务依然活跃，该记录对当前事务**不可见**
  + 不在列表中：说明该事务已经提交，该记录对当前事务**可见**



**Q：Mysql有哪些锁？**

**全局锁**

使用全局锁`flush tables with read lock`，整个数据库只读：

全局锁主要应用于做**全库逻辑备份**

`unlock tables`解锁

**表级锁**

**表锁**

不会出现死锁，发生锁冲突几率高，并发低。

```mysql
//表级别的共享锁，也就是读锁；
lock tables t_student read;
//表级别的独占锁，也就是写锁；
lock tables t_stuent write;
//解锁
unlock tables
```

**行级锁**

**InnoDB 引擎**是**支持行级锁**的，而 MyISAM 引擎并不支持行级锁。MySQL的行锁是通过**索引**加载的

```mysql
//对读取的记录加共享锁
select ... lock in share mode;
//对读取的记录加独占锁
select ... for update;
```

上面这两条语句必须在一个事务中，**因为当事务提交了，锁就会被释放**

共享锁（S锁）**满足读读共享，读写互斥。**独占锁（X锁）**满足写写互斥、读写互斥**。

- 行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。
- 如果是共享锁，两个事务可以锁同一个索引，排它锁则不能。
- insert，delete，update在事务中都会自动默认加上排它锁。

行级锁的类型主要有三类：

- **Record Lock**，记录锁，也就是仅仅把一条记录锁上；
- **Gap Lock**，间隙锁，锁定一个范围，但是不包含记录本身；
  - 范围 id 为（3，5）间隙锁，无法插入 id = 4 这条记录
- **Next-Key Lock**：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

事务执行 commit 后，事务过程中生成的锁都会被释放,**不存在互斥关系**



**Q：乐观锁和悲观锁**

悲观锁：先加锁再操作，行锁之类的都是悲观锁

乐观锁：先进行业务操作，只在最后实际更新数据时进行**检查数据是否被更新过**



**Q：Drop、Delete与Truncate的共同点和区别**

Drop、Delete、Truncate都表示删除

+ **Delete**用来删除表的**全部或者一部分数据行**，执行delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器
+ **Truncate**删除表中的**所有数据**，这个操作不能回滚，也不会触发这个表上的触发器，更快
+ **Drop**命令从数据库中**删除表**，不可回滚



**Q：说说三范式**

一范式：字段不可再分

二范式：所有的非主键字段，都必须完全依赖主键，不能部分依赖候选主键的一部分。表不可再分

成绩表里出现：学号、姓名、年龄、课程、成绩、学分

学分完全依赖于课程、姓名年龄完全依赖于学号、成绩完全依赖于学号+课程。

三范式：任何非主属性不依赖于其它非主属性：学生表里不能有学院主任之类的信息



**Q：数据库中的主键、超键、候选键、外键是什么？**

- **超键**：在关系中能唯一标识**元组的属性集**称为关系模式的超键
- **候选键**：不含有**多余属性的超键**称为候选键。也就是在候选键中，若再删除属性，就不是键了！
- **主键**：**用户选作元组标识的一个候选键程序主键**
- **外键**：如果关系模式**R中属性K是其它模式的主键**，那么**k在模式R中称为外键**。



**Q：MySQL架构分为哪两部分？**

Server层和存储引擎层

**Server 层负责建立连接、分析和执行 SQL：**核心功能模块、所有的内置函数、所有跨存储引擎的功能

+ 连接器：与客户端TCP连接；校验身份；检查权限
+ 查询缓存：查询的语句命中查询缓存则返回，否则继续执行
+ 解析器：**词法分析：构建出 SQL 语法树、语法分析：判断SQL是否合法**
+ 预处理器：检查 SQL的表或者字段是否存在、扩展*号
+ 优化器：**将 SQL 查询语句的执行方案确定下来，确定索引等**
+ 执行器：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

**存储引擎层负责数据的存储和提取：**支持 InnoDB、MyISAM、Memory 等多个存储引擎，最常用的存储引擎是InnoDB



**Q：为什么Innodb用自增id做主键**

表使用自增主键，每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置；写满后，自动开辟一个新的页；如果用非自增主键，每次新纪录都要被插到现有索引页中间某个位置， **频繁的移动、分页操作造成了大量的碎片**。