```c++
//头文件
#include<iostream>
#include<cstring>
#include<algorithm>
```



**邻接表**

```c++

const int N = 100010;
const int M = 2*N;
int h[N];//链表头
int e[M];//存边：存储是第idx条边的终点
int ne[M];//表示与第 idx 条边 同起点的下一条边的idx：一个链表
int w[M];
int idx;//第i条边
static int[] ne = new int[M];public static void add(int a,int b,int z){
        e[idx] = b;//
        ne[idx] = h[a];
    	w[idx] = z;
        h[a] = idx++; 
}
//有向图add(a,b,z);
//无向图add(a,b,z); add(b,a,z);
```



**深度优先搜索**

```c++
#include<iostream>
using namespace std;
int const N = 100010;
int const M = 2*N;
int h[N],e[M],ne[M];
bool st[N]; //哪些点被遍历过了
int idx;
void add(int a,int b)
{
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}
void dfs(int u)
{
    st[u] = true; //已经被搜过了
    for(int i = h[u];i != -1;i = ne[i])
    {
        int j = e[i];
        if(!st[j]) dfs(j);
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    memset(h,-1.sizeof(h));
    n--;
    while(n)
    {
        int x,y;
        scanf("%d%d",&x,&y);
    }
    return 0;
}
```



**广度优先搜索**

```c++
//可以开一个 d 数组用于记录起点到某个节点的最短距离，再开一个 p 数组记录是从哪个节点走到当前节点的。
void bfs(int u) {
    queue<int> q;
    st[u] = true, q.push(u);
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        for (int i = h[t]; ~i; i = ne[i]) {
            int v = e[i];
            if (!st[v]) st[v] = true, q.push(v);
        }
    }
}

vector<int> restore(int x) {
    vector<int> path;
    for (int v = x; ~v; v = p[v])
        path.push_back(v);
    reverse(path.begin(), path.end());
    return path;
}

```



<h4>背包问题</h4>

**01背包**

```c++
有N件物品和一个容量是V的背包。每件物品只能使用一次。
第i件物品的体积是 vi价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
//状态f[i][j]定义：前i个物品，背包容量j下的最优解（最大价值）
//当前背包容量不够：j<v[i],没得选f[i][j] = f[i-1][j]
//当前背包容量够：选第i个：f[i][j] = f[i-1][j-v[i]] + w[i];
//			   不选第i个：f[i][j] = f[i-1][j];
//取max
for(int i = 1; i <= n; i++) 
    for(int j = 1; j <= m; j++)
     {
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
         if(j < v[i]) 
             f[i][j] = f[i - 1][j];
         // 能装，需进行决策是否选择第i个物品
         else    
             f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
      }
//一维优化
for(int i = 1; i <= n; i++) 
    for(int j = m; j >= 0; j--)
    {
        if(j < v[i]) 
            f[i][j] = f[i - 1][j];  // 优化前
            f[j] = f[j];            // 优化后，该行自动成立，可省略。
        else    
            f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);  // 优化前
            f[j] = max(f[j], f[j - v[i]] + w[i]);                   // 优化后
    }   
```

**完全背包**

```c++
有 N种物品和一个容量是V的背包，每种物品都有无限件可用。
第i种物品的体积是vi，价值是wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
//状态f[i][j]定义：前i个物品，背包容量j下的最优解（最大价值）
//基础版本
for(int i = 1 ; i<=n ;i++)
    for(int j = 0 ; j<=m ;j++)
    {
        for(int k = 0 ; k*v[i]<=j ; k++)
            f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
    }
//优化：
//f[i,j] = max( f[i-1,j] , f[i-1,j-v]+w ,  f[i-1,j-2*v]+2*w , f[i-1,j-3*v]+3*w , .....)
//f[i,j-v]= max(            f[i-1,j-v]   ,  f[i-1,j-2*v] + w , f[i-1,j-3*v]+2*w , .....)
//f[i][j]=max(f[i,j-v]+w , f[i-1][j]) 
for(int i = 1 ; i <=n ;i++)
    for(int j = 0 ; j <=m ;j++)
    {
        f[i][j] = f[i-1][j];
        if(j-v[i]>=0)
            f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
    }
//一维优化：
for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)//注意了，这里的j是从小到大枚举，和01背包不一样
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
```

**多重背包**

```c++
//有N种物品和一个容量是V的背包
//第i种物品最多有si件,第i种物品的体积是vi，价值是wi。
//求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
//f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i] >> s[i];
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j <= m; j ++ )
            for (int k = 0; k <= s[i] && k * v[i] <= j; k ++ )
                f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + w[i] * k);
    cout << f[n][m] << endl;
    return 0;
}

//多重背包二进制优化：1,2,4,8,16,.....512  可以表示一定范围内任何一个数
#include<iostream>
using namespace std;

const int N = 12010, M = 2010;

int n, m;
int v[N], w[N]; //逐一枚举最大是N*logS
int f[M]; // 体积<M

int main()
{
    cin >> n >> m;
    int cnt = 0; //分组的组别
    for(int i = 1;i <= n;i ++)
    {
        int a,b,s;
        cin >> a >> b >> s;
        int k = 1; // 组别里面的个数
        while(k<=s)
        {
            cnt ++ ; //组别先增加
            v[cnt] = a * k ; //整体体积
            w[cnt] = b * k; // 整体价值
            s -= k; // s要减小
            k *= 2; // 组别里的个数增加
        }
        //剩余的一组
        if(s>0)
        {
            cnt ++ ;
            v[cnt] = a*s; 
            w[cnt] = b*s;
        }
    }

    n = cnt ; //枚举次数正式由个数变成组别数

    //01背包一维优化
    for(int i = 1;i <= n ;i ++)
        for(int j = m ;j >= v[i];j --)
            f[j] = max(f[j],f[j-v[i]] + w[i]);

    cout << f[m] << endl;
    return 0;
}
```



**分组背包**

```c++
有N组物品和一个容量是V的背包。
每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是vij，价值是wij，其中i是组号，j是组内编号。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
    #include<bits/stdc++.h>
using namespace std;

const int N=110;
int f[N][N];  //只从前i组物品中选，当前体积小于等于j的最大值
int v[N][N],w[N][N],s[N];   //v为体积，w为价值，s代表第i组物品的个数
int n,m,k;

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>s[i];
        for(int j=0;j<s[i];j++){
            cin>>v[i][j]>>w[i][j];  //读入
        }
    }

    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            f[i][j]=f[i-1][j];  //不选
            for(int k=0;k<s[i];k++){
                if(j>=v[i][k])     f[i][j]=max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);  
            }
        }
    }
    cout<<f[n][m]<<endl;
}
```





<h4>图论</h4>

**Dijkstra**

```c++
//给定一个 n个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。
//请你求出1号点到n号点的最短距离，如果无法从1号点走到n号点，则输出−1。
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N=510;

int g[N][N];    //为稠密阵所以用邻接矩阵存储
int dist[N];    //用于记录每一个点距离第一个点的距离
bool st[N];     //用于记录该点的最短距离是否已经确定

int n,m;

int Dijkstra()
{
    memset(dist, 0x3f,sizeof dist);     //初始化距离  0x3f代表无限大

    dist[1]=0;  //第一个点到自身的距离为0

    for(int i=0;i<n;i++)      //有n个点所以要进行n次 迭代
    {
        int t=-1;       //t存储当前访问的点

        for(int j=1;j<=n;j++)   //这里的j代表的是从1号点开始
            if(!st[j]&&(t==-1||dist[t]>dist[j]))     
                t=j;

        st[t]=true;   

        for(int j=1;j<=n;j++)           //依次更新每个点所到相邻的点路径值
            dist[j]=min(dist[j],dist[t]+g[t][j]);
    }

    if(dist[n]==0x3f3f3f3f) return -1;  //如果第n个点路径为无穷大即不存在最低路径
    return dist[n];
}
int main()
{
    cin>>n>>m;

    memset(g,0x3f,sizeof g);    //初始化图 因为是求最短路径
                                //所以每个点初始为无限大

    while(m--)
    {
        int x,y,z;
        cin>>x>>y>>z;
        g[x][y]=min(g[x][y],z);     //如果发生重边的情况则保留最短的一条边
    }

    cout<<Dijkstra()<<endl;
    return 0;
}
```

