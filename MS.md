<h4>C++基础</h4>

**Q：C和C++区别？**

A：

+ C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多**新特性**，**如引用、智能指针、auto变量等**
+ C++是**面对对象**的编程语言；C语言是**面对过程**的编程语言
+ C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少**新特性**来**改善安全性**，如const常量、引用、**cast转换**、智能指针、try—catch等等；
+ C++**可复用性**高，C++引入了**模板**的概念，后面在此基础上，实现了方便开发的标准模板库STL。

**Q：C/C++中结构体的区别**

A：

+ C中不允许成员函数存在、对内部变量的访问权限只能是public，不可继承，要加关键字，无法直接初始化成员
+ C++允许成员函数存在，可以设置三种访问权限，可继承，可省去struct关键字，可以直接初始化

**Q：C++代码编译过程？**

A：

- 四个阶段：预编译、编译、汇编、链接
- 预编译：展开所有的宏定义、处理所有条件预编译指令，处理include，过滤所有注释，添加行号和文件名标识
- 编译：词法分析、语法分析、语义分析、代码优化、生成汇编代码
- 汇编：将汇编代码转变成机器可以执行的指令
- 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序：静态链接(.lib/.a)，是在链接的时候就已经把要调用的函数或者过程**链接到了生成的可执行文件**中；动态链接(.dll/.so)，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息

**Q：static关键字作用**

A：

+ **定义全局静态变量和局部静态变量**：初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。
+ **定义静态函数**：函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在**本源文件**中使用
+ **定义类中的静态成员变量**：静态数据成员都**共享**这一块静态存储空间。
+ **定义类中的静态成员函数**：静态成员都**共享**这一块静态存储空间。

<h4>虚函数</h4>

**Q：虚继承的作用？**

A：虚继承是C++中的一种继承方式，如果一个类继承多个类，但这些类又继承自同一个基类，会导致在派生类中存在多个基类子对象的副本，导致多次访问同一份基类数据，引发二义性问题。

虚继承通过使用虚基类来解决问题，被继承的基类将被标记为虚基类，意味着在派生类中只保留一个基类子对象的副本。**virtual public**

**Q：为什么不能设置虚构造函数？**

A：C++规定构造函数不能是虚函数，构造函数是在对象创建时被调用的，需要先调用基类的构造函数，然后才能调用派生类的构造函数，这个过程在编译期确定，因此无法实现多态，将导致编译错误或运行错误

**Q：虚函数表的作用是什么？**

A：虚函数表用于实现C++中的运行时多态性和动态绑定，如果一个类声明了虚函数，编译器会在该类的对象中生成一个指向虚函数表的指针，这个指针被称为**虚函数表指针**。

虚函数表是一个包含了该类中所有虚函数的指针数组（每个类只有一个），指针指向了对应的虚函数实现代码。当一个对象调用虚函数时，实际上是通过该对象的虚函数表指针找到了对应的虚函数实现代码，并进行调用。

**Q：多态性和动态绑定**

A：多态性指的是不同的对象可以调用同一个虚函数，但根据对象所属的类的不同，实际调用的虚函数实现代码也不同。

动态绑定则指的是在运行时根据对象的类型来确定调用哪个虚函数实现代码，而不是在编译时确定。



<h4>指针/智能指针</h4>

**Q：shared_ptr和unique_ptr 的实现原理**

A：能够管理动态分配的内存资源，并在适当的时候自动释放这些资源；

unique_ptr和 shared_ptr都是通过模板类实现的，有一个指向所管理资源的指针，以及一个指向控制块的指针，控制块中存储了引用计数等信息。

前者使用引用计数跟踪有多少个shared_ptr指向同一个资源，当引用计数变为 0 时，资源会被自动释放。

后者不可拷贝，销毁时自动释放管理的资源。

**Q：什么是智能指针？分为哪几种？**

A：智能指针是一种C++的指针类型，本质是一个类，目的是帮助程序员自动管理动态内存，避免内存泄漏和野指针等常见问题。

分为：**auto_ptr(已废弃)**、**shared_ptr**、**unique_ptr**、**weak_ptr**四种

**shared_ptr：**拥有其所指向的对象，每个shared_ptr会记录有多少个shared_ptr与他指向的对象，该类的析构函数会递减其引用计数，当引用计数归零时，通过特殊的析构函数释放自己所管理的对象。用make_shared<T>创建

**unique_ptr：**独占其指向的对象，需要将其绑定到一个new返回的指针上，直接初始化，不支持普通的拷贝赋值，只能拷贝赋值一个将要销毁的ptr

**weak_ptr：**用于保存一个shared_ptr对象的弱引用，不会导致引用计数器增加

<h4>其他</h4>

**Q：如何在代码层面关闭编译器优化？**

A：\#pragma optimize("", off)：关闭整个文件中的所有优化；**attribute**((optimize("O0")))关闭单个函数中的优化，写在函数定义上方







<h3>计算机网络</h3>

**Q：TCP和UDP的区别？**

A：

+ TCP：面向连接的，通信之前需要三次握手建立连接；UDP：无连接的
  + TCP：可靠服务，数据无差错，不丢失，不重复，按序到达；UDP：尽力而为，不保证可靠交付		
  + TCP：面向字节流，将数据视作一连串无结构的字节流，数据无边界长度限制；UDP：面向报文，每个数据报有长度
+ TCP：只能一对一通信；UDP：支持一对一、一对多、多对多通信
+ TCP：有流量控制、拥塞控制、全双工通信；UDP：没有

**Q：什么时候使用TCP，什么时候使用UDP？**

A：当应用需要可靠传输和流控制时使用TCP：文件传输、邮件传输、网页浏览等—保证数据完整和正确；

当应用实时性高、数据传输量小时使用UDP：视频流传输、网络游戏、DNS查询	—要求实时性

